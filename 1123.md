Ок, давай зробимо це через `project` замість helpdesk і залишимось тільки на `odoorpc` в гейтвеї.
Я опишу схему + дам готові файли, які ти просто додаси в свій репо.

## Концепція синку

Приймаємо такі правила (якщо хочеш потім — поміняємо):

* **Odoo 1** — «головна»:

  * тут створюються **проєкти** та **таски**;
  * при створенні / оновленні викликає FastAPI-гейтвей.
* **Odoo 2** — «дзеркало»:

  * гейтвей через `odoorpc` створює / оновлює там `project.project` і `project.task`;
  * коли **таск змінюється в Odoo 2** — Odoo 2 викликає гейтвей і той оновлює відповідний таск в Odoo 1.

Щоб зв’язати записи між базами, додаємо **кастомні поля**:

### Кастомні поля в Odoo

**На Odoo 1:**

* `project.project`:

  * `x_odoo2_project_id` (Integer) — ID цього проєкту в Odoo 2
* `project.task`:

  * `x_odoo2_task_id` (Integer) — ID цього таска в Odoo 2

**На Odoo 2:**

* `project.project`:

  * `x_odoo1_project_id` (Integer) — ID цього проєкту в Odoo 1
* `project.task`:

  * `x_odoo1_task_id` (Integer) — ID цього таска в Odoo 1

Це можна зробити через Studio / Settings → Technical → Database Structure → Models.

---

## 1. Конфіг для двох Odoo через env

В твій `.env.dev` / `.env.prod` (де в тебе зараз параметри для проксі) додай, наприклад:

```env
# Odoo 1
ODOO_1_HOST=odoo1
ODOO_1_PORT=8069
ODOO_1_DB=odoo1_db
ODOO_1_USER=admin
ODOO_1_PASSWORD=admin
ODOO_1_PROTOCOL=jsonrpc

# Odoo 2
ODOO_2_HOST=odoo2
ODOO_2_PORT=8069
ODOO_2_DB=odoo2_db
ODOO_2_USER=admin
ODOO_2_PASSWORD=admin
ODOO_2_PROTOCOL=jsonrpc
```

(Назви й хости підставиш свої — головне, щоб з контейнера FastAPI вони резолвились.)

---

## 2. Новий файл `app/odoo_client.py`

Створюєш клієнтів до обох Odoo через `odoorpc`:

```python
# app/odoo_client.py
from __future__ import annotations

import os
from dataclasses import dataclass
from typing import Optional

import odoorpc


@dataclass
class OdooConfig:
    host: str
    port: int
    db: str
    user: str
    password: str
    protocol: str = "jsonrpc"


def load_odoo_config(prefix: str) -> OdooConfig:
    return OdooConfig(
        host=os.getenv(f"{prefix}_HOST", "localhost"),
        port=int(os.getenv(f"{prefix}_PORT", "8069")),
        db=os.getenv(f"{prefix}_DB", "odoo"),
        user=os.getenv(f"{prefix}_USER", "admin"),
        password=os.getenv(f"{prefix}_PASSWORD", "admin"),
        protocol=os.getenv(f"{prefix}_PROTOCOL", "jsonrpc"),
    )


class OdooClient:
    def __init__(self, cfg: OdooConfig) -> None:
        self.cfg = cfg
        self._client: Optional[odoorpc.ODOO] = None

    def connect(self) -> odoorpc.ODOO:
        if self._client is None:
            self._client = odoorpc.ODOO(
                self.cfg.host,
                port=self.cfg.port,
                protocol=self.cfg.protocol,
            )
            self._client.login(self.cfg.db, self.cfg.user, self.cfg.password)
        return self._client

    @property
    def env(self):
        """
        Shortcut для self.connect().env — як env в самому Odoo.
        """
        return self.connect().env


# Odoo 1 == "джерело"
odoo1_client = OdooClient(load_odoo_config("ODOO_1"))
# Odoo 2 == "ціль / дзеркало"
odoo2_client = OdooClient(load_odoo_config("ODOO_2"))
```

---

## 3. Модуль для проєктів: `app/odoo_projects_gateway.py`

Тут вся логіка:

* апі-ендпоінти FastAPI;
* синк проєктів 1 → 2;
* синк тасків 1 → 2;
* зворотний синк тасків 2 → 1 (оновлення).

```python
# app/odoo_projects_gateway.py
from __future__ import annotations

from typing import Optional

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel

from .odoo_client import odoo1_client, odoo2_client

router = APIRouter(
    prefix="/api/v1/odoo/projects",
    tags=["odoo-projects"],
)

# ==========
# Pydantic схеми
# ==========


class SyncProjectFrom1To2Request(BaseModel):
    project_id_in_1: int


class SyncProjectFrom1To2Response(BaseModel):
    project_id_in_2: int


class SyncTaskFrom1To2Request(BaseModel):
    task_id_in_1: int


class SyncTaskFrom1To2Response(BaseModel):
    task_id_in_2: int


class TaskChangedIn2Request(BaseModel):
    task_id_in_2: int


class TaskChangedIn2Response(BaseModel):
    task_id_in_1: int


# ==========
# Допоміжні функції
# ==========


def _map_task_stage_by_name(source_stage, target_env) -> Optional[int]:
    """Мапає stage_id (project.task.type) за ім’ям між базами."""
    if not source_stage:
        return None

    TaskStage = target_env["project.task.type"]
    ids = TaskStage.search([("name", "=", source_stage.name)], limit=1)
    return ids[0] if ids else None


# ==========
# Синк проєктів 1 → 2
# ==========


def sync_project_from_1_to_2(project_id_in_1: int) -> int:
    """
    Читаємо project.project з Odoo 1 і створюємо/оновлюємо відповідний
    project.project в Odoo 2.

    Використовуються поля-зв’язки:
      - в Odoo 2: project.project.x_odoo1_project_id
      - в Odoo 1: project.project.x_odoo2_project_id (опційно оновлюємо)
    """
    env1 = odoo1_client.env
    env2 = odoo2_client.env

    Project1 = env1["project.project"]
    Project2 = env2["project.project"]

    proj1 = Project1.browse(project_id_in_1)
    if not proj1.exists():
        raise HTTPException(status_code=404, detail="project not found in Odoo 1")

    # шукаємо чи вже є цей проєкт в Odoo 2
    existing_ids = Project2.search([("x_odoo1_project_id", "=", project_id_in_1)], limit=1)

    vals_2 = {
        "name": proj1.name,
        "partner_id": proj1.partner_id.id or False,
        "user_id": proj1.user_id.id or False,
        "company_id": proj1.company_id.id or False,
        # поле-зв’язка
        "x_odoo1_project_id": project_id_in_1,
    }

    if existing_ids:
        project_id_in_2 = existing_ids[0]
        proj2 = Project2.browse(project_id_in_2)
        proj2.write(vals_2)
    else:
        project_id_in_2 = Project2.create(vals_2)

    # опційно — зберігаємо зворотній ID в Odoo 1
    if hasattr(proj1, "x_odoo2_project_id"):
        proj1.write({"x_odoo2_project_id": project_id_in_2})

    return project_id_in_2


# ==========
# Синк тасків 1 → 2
# ==========


def sync_task_from_1_to_2(task_id_in_1: int) -> int:
    """
    Читаємо project.task з Odoo 1 і створюємо/оновлюємо відповідний
    project.task в Odoo 2.

    Поля-зв’язки:
      - в Odoo 2: project.task.x_odoo1_task_id
      - в Odoo 1: project.task.x_odoo2_task_id (опційно оновлюємо)
    """
    env1 = odoo1_client.env
    env2 = odoo2_client.env

    Task1 = env1["project.task"]
    Task2 = env2["project.task"]

    task1 = Task1.browse(task_id_in_1)
    if not task1.exists():
        raise HTTPException(status_code=404, detail="task not found in Odoo 1")

    # гарантуємо, що відповідний проєкт є в Odoo 2
    project_id_in_2 = None
    if task1.project_id:
        project_id_in_2 = sync_project_from_1_to_2(task1.project_id.id)

    # шукаємо таск по x_odoo1_task_id
    existing_ids = Task2.search([("x_odoo1_task_id", "=", task_id_in_1)], limit=1)

    # мапимо stage_id по імені
    stage_id_in_2 = None
    if task1.stage_id:
        stage_id_in_2 = _map_task_stage_by_name(task1.stage_id, env2)

    vals_2 = {
        "name": task1.name,
        "user_id": task1.user_id.id or False,
        "date_deadline": task1.date_deadline or False,
        "kanban_state": task1.kanban_state or "normal",
        "company_id": task1.company_id.id or False,
        # зв’язуємо з проєктом в Odoo 2
        "project_id": project_id_in_2 or False,
        # поле-зв’язка
        "x_odoo1_task_id": task_id_in_1,
    }
    if stage_id_in_2:
        vals_2["stage_id"] = stage_id_in_2

    if existing_ids:
        task_id_in_2 = existing_ids[0]
        task2 = Task2.browse(task_id_in_2)
        task2.write(vals_2)
    else:
        task_id_in_2 = Task2.create(vals_2)

    # опційно — зворотнє посилання в Odoo 1
    if hasattr(task1, "x_odoo2_task_id"):
        task1.write({"x_odoo2_task_id": task_id_in_2})

    return task_id_in_2


# ==========
# Синк змін таску 2 → 1
# ==========


def sync_task_from_2_to_1(task_id_in_2: int) -> int:
    """
    Коли таск змінюється в Odoo 2 — ми оновлюємо відповідний таск у Odoo 1.

    Беремо лише таски, які мають x_odoo1_task_id.
    """
    env1 = odoo1_client.env
    env2 = odoo2_client.env

    Task1 = env1["project.task"]
    Task2 = env2["project.task"]

    task2 = Task2.browse(task_id_in_2)
    if not task2.exists():
        raise HTTPException(status_code=404, detail="task not found in Odoo 2")

    origin_id = getattr(task2, "x_odoo1_task_id", False)
    if not origin_id:
        raise HTTPException(
            status_code=400,
            detail="task in Odoo 2 has no x_odoo1_task_id, cannot sync back",
        )

    task1 = Task1.browse(origin_id)
    if not task1.exists():
        raise HTTPException(
            status_code=404,
            detail="original task not found in Odoo 1",
        )

    # мапимо stage_id назад по імені
    stage_id_in_1 = None
    if task2.stage_id:
        stage_id_in_1 = _map_task_stage_by_name(task2.stage_id, env1)

    vals_1 = {
        "name": task2.name,
        "user_id": task2.user_id.id or False,
        "date_deadline": task2.date_deadline or False,
        "kanban_state": task2.kanban_state or "normal",
    }
    if stage_id_in_1:
        vals_1["stage_id"] = stage_id_in_1

    # **важливо**: description в project.task — HTML-поле з історією,
    # в 18-ці воно інколи лагає при масових оновленнях.
    # Якщо треба — додаси сюди description, але якщо вилізуть ValidationError
    # про "different history for field 'description'" — просто прибери його.
    # vals_1["description"] = task2.description

    task1.write(vals_1)
    return origin_id


# ==========
# FastAPI endpoints
# ==========


@router.post(
    "/sync-project-from-1-to-2",
    response_model=SyncProjectFrom1To2Response,
)
def api_sync_project_from_1_to_2(payload: SyncProjectFrom1To2Request):
    """
    Викликається з Odoo 1 (сервер-екшн / automation), коли створили/оновили проект.
    """
    project_id_in_2 = sync_project_from_1_to_2(payload.project_id_in_1)
    return SyncProjectFrom1To2Response(project_id_in_2=project_id_in_2)


@router.post(
    "/sync-task-from-1-to-2",
    response_model=SyncTaskFrom1To2Response,
)
def api_sync_task_from_1_to_2(payload: SyncTaskFrom1To2Request):
    """
    Викликається з Odoo 1, коли створили/оновили таск.
    """
    task_id_in_2 = sync_task_from_1_to_2(payload.task_id_in_1)
    return SyncTaskFrom1To2Response(task_id_in_2=task_id_in_2)


@router.post(
    "/task-changed-in-2",
    response_model=TaskChangedIn2Response,
)
def api_task_changed_in_2(payload: TaskChangedIn2Request):
    """
    Викликається з Odoo 2, коли там змінили таск.
    """
    task_id_in_1 = sync_task_from_2_to_1(payload.task_id_in_2)
    return TaskChangedIn2Response(task_id_in_1=task_id_in_1)
```

---

## 4. Підключаємо роутер в `app/main.py`

В твоєму `app/main.py` (де зараз FastAPI + проксі) потрібно:

```python
# app/main.py (фрагмент)

from fastapi import FastAPI

from .odoo_projects_gateway import router as odoo_projects_router
# ... інші імпорти

app = FastAPI(title="FastAPI Single Proxy + Odoo gateway")

# старі маршрути (health, proxy, і тд)
# app.include_router(proxy_router, prefix="/api/v1/proxy")

# новий роутер для Odoo-проєктів
app.include_router(odoo_projects_router)
```

Якщо в тебе є фабрика типу `def create_app():` — просто зроби `app.include_router(odoo_projects_router)` всередині неї.

---

## 5. Як це дергати з Odoo 1 і Odoo 2

Тут уже **всередині Odoo** ти можеш хоч `python-requests`, хоч `urllib`; гейтвей при цьому говорить з Odoo тільки через `odoorpc`, як ти хотів.

### Odoo 1 — тригер при створенні/оновленні таска

Сервер-екшн (Python code) на `project.task` в Odoo 1, щось типу:

```python
import requests

base_url = "http://your-fastapi-gateway:8000"

task = records  # поточний project.task
payload = {"task_id_in_1": task.id}

requests.post(
    f"{base_url}/api/v1/odoo/projects/sync-task-from-1-to-2",
    json=payload,
    timeout=5,
)
```

Аналогічно для проєктів:

```python
payload = {"project_id_in_1": project.id}
requests.post(
    f"{base_url}/api/v1/odoo/projects/sync-project-from-1-to-2",
    json=payload,
    timeout=5,
)
```

### Odoo 2 — тригер при зміні таска

Сервер-екшн на `project.task` в Odoo 2:

```python
import requests

base_url = "http://your-fastapi-gateway:8000"

task = records
payload = {"task_id_in_2": task.id}

requests.post(
    f"{base_url}/api/v1/odoo/projects/task-changed-in-2",
    json=payload,
    timeout=5,
)
```

---

## Підсумок

Що ти отримуєш зараз:

* FastAPI-гейтвей, який:

  * тримає два `odoorpc`-клієнти до Odoo 1 і Odoo 2;
  * вміє:

    * синкати `project.project` 1 → 2;
    * синкати `project.task` 1 → 2;
    * при зміні таска в Odoo 2 оновлювати відповідний таск в Odoo 1.
* Вся логіка обміну через один центральний сервіс, а Odoo між собою напряму не говорять.

Якщо хочеш, наступним кроком можемо:

* додати **bulk-синк** (по фільтру/даті);
* робити просту чергу / retry (щоб не втратити апдейти);
* розширити список полів, які синкаються, або зробити «mapping config» в YAML.
